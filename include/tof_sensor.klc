PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'Distance Sensor'
%NOLOCKGROUP
%UNINITVARS

%include namespace.m

%include errors.klt
%include tof_sensor.klt

%include errors.klh
%include math.klh
%include tof_sensor.klh
%include tof_sensor.private.klh

--private
ROUTINE read_measurement_
  BEGIN
    last_range = calib_
    --if laser out of range return uninitialized value
    IF (ABS(last_range) > this.m*this.max) THEN
      SET_UNINIT_R('class_name', 'last_range')
    ENDIF
  END read_measurement_

ROUTINE read_range_
  VAR
    time_out : BOOLEAN
    i : INTEGER
  BEGIN
    --ranging measurement is a rolling
    --list of values updated every 
    --MAX_SAMPLES*SAMPLE_TIME ms
    IF this.last_index > MAX_SAMPLES THEN
      this.last_index = 1
    ENDIF

    --get measurement
    this.measuremnts[this.last_index] = calib_

    IF (ABS(this.measuremnts[this.last_index]) > this.m*this.max) THEN
      -- warning.. might not be a solution?????
      --if laser out of range uninitialize whole sample
      this.measuremnts = uninit_r
    ENDIF

    this.last_index = this.last_index + 1

    --average to get mean reading
    --averaging ignores uninitalized values
    -- warning.. if all values are uninitialized
    --           function returns 0. May not be
    --           desirable
    last_range = math__average_real(this.measuremnts)
  END read_range_

--routine to convert analog signal to real value
ROUTINE calib_
  BEGIN
    SELECT this.mode OF
      CASE(MODE_4_20MA):
        karelError(INVALID_TYPE_CODE, '4-20 ma has not been implemented yet.', ER_ABORT)
      CASE(MODE_0_5V):
        RETURN(this.m * AIN[this.pin] + this.b)
      CASE(MODE_5_5V):
        IF AIN[this.pin] > this.max THEN
          RETURN(this.m * AIN[this.pin] + this.b)
        ELSE
          RETURN(this.m * AIN[this.pin])
        ENDIF
      ELSE:
        karelError(INVALID_TYPE_CODE, 'tof sensor mode is not properly selected.', ER_ABORT)
    ENDSELECT

  END calib_

--initialization
ROUTINE constructor 
  BEGIN
    --set pin
    this.pin = io_num
    --set analog mode
    this.mode = ai_mode 
    --set linear interpolation
    this.m = slope
    this.b = intercpt
    this.max = max_ai
    --set sampling time
    this.sample_time = SAMPLE_MS
    --set ranging index
    this.last_index = 1
    --uninitialize measurement array
    this.measuremnts = uninit_r
    -- ranging type
    this.meas_type = 1 -- default to single measurement
  END constructor

ROUTINE destructor
  BEGIN
    --uninitialize measurement array
    this.measuremnts = uninit_r
    --clear pin number
    this.pin = 0
  END destructor

--set sample time
ROUTINE set_sample_time
  BEGIN
    this.sample_time = smpl_tme
  END set_sample_time

ROUTINE set_measurement_type
  BEGIN
    SELECT meas_type OF
      CASE(1):
        this.meas_type = 1 -- single measurement
      CASE(2):
        this.meas_type = 2 -- averaged measurements
      ELSE:
        karelError(INVALID_TYPE_CODE, 'measurement type for sensor not properly set.', ER_ABORT)
    ENDSELECT
  END set_measurement_type

--ranging
--public exposure for ranging
ROUTINE read_measurement
  BEGIN
    read_measurement_
    RETURN(last_range)
  END read_measurement

ROUTINE read_range
  BEGIN
    read_range_
    RETURN(last_range)
  END read_range

--task
BEGIN
  WHILE(TRUE) DO
    IF (this.meas_type = 1) THEN
      read_measurement_
    ENDIF
    IF (this.meas_type = 2) THEN
      read_range_
    ENDIF

    DELAY this.sample_time
  ENDWHILE
END class_name

